{"version":3,"sources":["webpack:///path---posts-3-65ce2f5b9207722d610a.js","webpack:///./.cache/json/posts-3.json"],"names":["webpackJsonp","362","module","exports","data","markdownRemark","html","indexJson","title","pathContext","slug","pid","next","prev"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,6z5BAAi47BC,WAAcC,MAAA,sCAA6CC,aAAgBC,KAAA,YAAAC,IAAA,EAAAC,KAAA,WAAAC,KAAA","file":"path---posts-3-65ce2f5b9207722d610a.js","sourcesContent":["webpackJsonp([81878219163735],{\n\n/***/ 362:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p> Spark DataSource API 的提出使得各个数据源按规范实现适配，那么就可以高效的利用Spark 的计算能力。典型如Parquet,CarbonData,Postgrep(JDBC类的都OK)等实现。本文则介绍如何利用Spark DataSource 对标准Rest接口实现读取</p>\\n</blockquote>\\n<h2>引子</h2>\\n<p>先说下这个需求的来源。通常在一个流式计算的主流程里，会用到很多映射数据，譬如某某对照关系，而这些映射数据通常是通过HTTP接口暴露出来的,尤其是外部系统，你基本没有办法直接通过JDBC去读库啥的。</p>\\n<p>上面是一个点，其次是从HTTP读到的JSON数据，我其实需要做扁平化处理的。现在如果SQL作用于JSON数据可以解决简单的嵌套问题，但是更复杂的方式是没有太大办法的。</p>\\n<p>比如下面格式的：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>{\\n  \\\"status\\\":\\\"200\\\",\\n  \\\"data\\\":[\\n   \\\"id\\\":1,\\n   \\\"userid\\\":2,\\n   \\\"service\\\":{\\n    \\\"3\\\":{\\\"a\\\":1,\\\"b\\\":2},\\n    \\\"2\\\":{\\\"a\\\":3,\\\"b\\\":2},\\n    .....\\n  }\\n\\n]\\n}</code></pre>\\n      </div>\\n<p>最好能展开成这种格式才能够被主流程直接join使用：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code> {id:1,userid:2,service:3,a:1,b:2}\\n {id:1,userid:2,service:2,a:3,b:2}</code></pre>\\n      </div>\\n<p>所以为了实现同事的需求，我需要第一将Rest接口的获取方式用标准的DataSource API 来实现，其次提供一个能够做如上合并规则的模块，并且允许配置。</p>\\n<p>最后实现的效果参看： <a href=\\\"https://gist.github.com/allwefantasy/42fd5afa2dc76f7bcc56e9e72977eaa3\\\">Rest DataSource</a></p>\\n<p>实现代码可以参看：<a href=\\\"https://github.com/allwefantasy/streamingpro/tree/master/src/main/java/org/apache/spark/sql/execution/datasources/rest/json\\\">RestJSONDataSource</a></p>\\n<h2>实现目标</h2>\\n<p>先看看DataSource API 的样子：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>val df <span class=\\\"token operator\\\">=</span> SQLContext<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getOrCreate</span><span class=\\\"token punctuation\\\">(</span>sc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>\\nread<span class=\\\"token punctuation\\\">.</span>\\n<span class=\\\"token function\\\">format</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"driver class\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token comment\\\">//驱动程序，类似JDBC的 driver class </span>\\n<span class=\\\"token function\\\">options</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Map</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">...</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span> <span class=\\\"token comment\\\">//你需要额外传递给驱动的参数</span>\\n<span class=\\\"token function\\\">load</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"url\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//资源路径</span>\\n</code></pre>\\n      </div>\\n<p>如果做成配置化则是：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token string\\\">\\\"name\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">\\\"streaming.core.compositor.spark.source.SQLSourceCompositor\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n        <span class=\\\"token string\\\">\\\"params\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span>\\n          <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token string\\\">\\\"format\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">\\\"org.apache.spark.sql.execution.datasources.rest.json\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n            <span class=\\\"token string\\\">\\\"url\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">\\\"http://[your dns]/path\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n            <span class=\\\"token string\\\">\\\"xPath\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">\\\"$.data\\\"</span>\\n          <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">]</span>\\n      <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<h2>DefaultSource的实现</h2>\\n<p>定义</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>org.apache.spark.sql.execution.datasources.rest.json.DefaultSource\\nextends RelationProvider \\nwith DataSourceRegister</code></pre>\\n      </div>\\n<p>这是比较典型的命名规范。rest 代表支持的是rest作为接口，json则代表rest接口的数据是json格式的，包的命名让人一目了然。</p>\\n<p>先看看DefaultSource继承的两个接口</p>\\n<ul>\\n<li>DataSourceRegister</li>\\n</ul>\\n<p>该接口只有一个<code>shortName</code> 方法。我们看到上面的包名是很长的，你可以给一个更简短的名字：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>org.apache.spark.sql.execution.datasources.rest.json \\n==>\\nrestJSON</code></pre>\\n      </div>\\n<p>所以具体实现就变成了：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>override def shortName(): String = \\\"restJSON\\\"</code></pre>\\n      </div>\\n<ul>\\n<li>RelationProvider</li>\\n</ul>\\n<p>这个接口也只有一个方法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>def createRelation(sqlContext: SQLContext, parameters: Map[String, String]): BaseRelation</code></pre>\\n      </div>\\n<p>其返回值BaseRelation对象描述了数据源和Spark SQL交互。createRelation方法允许你根据用户定义的参数<code>parameters</code> 创建一个合适的BaseRelation的实现类。</p>\\n<p>其实除了这个，还有一些携带更多信息的继承自RelationProvider的类，譬如：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>SchemaRelationProvider 允许你直接传递Schema信息给BaseRelation实现。\\nHadoopFsRelationProvider  除了参数帮你加了path等，返回值也帮你约定成HadoopFsRelation. HadoopFsRelation 提供了和HDFS交互的大部分实现</code></pre>\\n      </div>\\n<p>在我们的实现里，只要实现基础的RelationProvider就好。</p>\\n<p>我们来看下DefaultSource.createRelation的具体代码：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>override def createRelation(\\n                               sqlContext: SQLContext,\\n                               //还记的DataSource的options方法么，parameters就是\\n                               //用户通过options传递过来的\\n                               parameters: Map[String, String]\\n                               ): BaseRelation = {\\n//因为我们并需要用户提供schema\\n//而是从JSON格式数据自己自己推导出来的\\n// 所以这里有个采样率的概念\\n    val samplingRatio = parameters.get(\\\"samplingRatio\\\").map(_.toDouble).getOrElse(1.0)\\n// 还记得DataSource的 path么？ 理论上是应该通过那个传递过来的，然而\\n//这里是直接通过potions传递过来的。\\n    val url = parameters.getOrElse(\\\"url\\\", \\\"\\\")\\n// 我们需要能够对通过XPATH语法抽取我们要的数据，比如\\n//前面的例子，我们需要能够抽取出data那个数组\\n    val xPath = parameters.getOrElse(\\\"xPath\\\", \\\"$\\\")\\n   //这里是核心\\n    new RestJSONRelation(None, url, xPath, samplingRatio, None)(sqlContext)\\n  }</code></pre>\\n      </div>\\n<p>源码中已经做了说明。这里RestJSONRelation是整个核心，它实现了Spark SQL 和数据源的交互。RestJSONRelation继承自BaseRelation，TableScan等基类</p>\\n<h2>RestJSONRelation</h2>\\n<p>先看看RestJSONRelation 的签名：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">private</span><span class=\\\"token punctuation\\\">[</span>sql<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">RestJSONRelation</span><span class=\\\"token punctuation\\\">(</span>\\n                           val inputRDD<span class=\\\"token punctuation\\\">:</span> Option<span class=\\\"token punctuation\\\">[</span>RDD<span class=\\\"token punctuation\\\">[</span>String<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n                           val url<span class=\\\"token punctuation\\\">:</span> String<span class=\\\"token punctuation\\\">,</span>\\n                           val xPath<span class=\\\"token punctuation\\\">:</span> String<span class=\\\"token punctuation\\\">,</span>\\n                           val samplingRatio<span class=\\\"token punctuation\\\">:</span> Double<span class=\\\"token punctuation\\\">,</span>\\n                           val maybeDataSchema<span class=\\\"token punctuation\\\">:</span> Option<span class=\\\"token punctuation\\\">[</span>StructType<span class=\\\"token punctuation\\\">]</span>\\n                           <span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">(</span>@transient val sqlContext<span class=\\\"token punctuation\\\">:</span> SQLContext<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">BaseRelation</span> <span class=\\\"token keyword\\\">with</span> TableScan <span class=\\\"token punctuation\\\">{</span>\\n</code></pre>\\n      </div>\\n<p>这些参数是你随便定义的。当然，url,xPath,smaplingRatio具体的含义在上一章节都提到了。</p>\\n<p>和数据源进行交互有两个必要的信息需要获取：</p>\\n<ul>\\n<li>\\n<p>Schema 信息。只有两种方法：用户告知你，或者程序自己根据数据推导。关于schema信息这块，BaseRelation还提供了几个基础的约定：</p>\\n<ul>\\n<li>needConversion，是否需类型转换，因为Spark SQL内部的表示是Row,里面的数据需要特定的类型，比如String会被转化成UTF8String。默认为true,官方也是说不要管他就好。</li>\\n<li>unhandledFilters, 返回一些数据源没有办法pushdown的filter。这样解析器就知道可以在Spark内部做filter了。否则Spark 会傻傻的以为你做了过滤，然后数据计算结果就错了。</li>\\n</ul>\\n</li>\\n<li>\\n<p>数据扫描的方法。 目前Spark SQL 提供了四种</p>\\n<ul>\\n<li>TableScan 全表扫描</li>\\n<li>PrunedScan  可以指定列，其他的列数据源可以不用返回</li>\\n<li>PrunedFilteredScan 指定列，并且还可以加一些过滤条件，只返回满足条件的数据。这个也就是我们常说的数据源<code>下沉(pushdown)</code>操作。</li>\\n<li>CatalystScan 和PrunedFilteredScan类似，支持列过滤，数据过滤，但是接受的过滤条件是Spark 里的Expression。 理论上会更灵活些。话说在Spark源码)里(1.6.1版本)，我没有看到这个类的具体实现案例。\\n这里我们只要实现一个简单的TableScan就可以了，因为拿的是字典数据，并不需要做过滤。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Schema推导</h2>\\n<p>BaseRelation是需要你给出Schema的。这里我们会先定义一个dataSchema的lazy属性，这样防止schema方法被反复调用而反复推导。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>override def schema: StructType = dataSchema\\nlazy val dataSchema = .....</code></pre>\\n      </div>\\n<p>因为我们是根据数据推导Schema,所以首先要获取数据。我们定义一个方法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>private def createBaseRdd(inputPaths: Array[String]): RDD[String]</code></pre>\\n      </div>\\n<p>inputPaths 我沿用了文件系统的概念，其实在我们这里就是一个URL。我们知道，最终Spark SQL 的直接数据源都是RDD的。所以这里我们返回的也是RDD[String]类型。具体实现很简单，就是通过HttpClient根据inputPaths拿到数据之后makeRDD一下就可以了。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token comment\\\">//应该要再加个重试机制就更好了</span>\\n<span class=\\\"token keyword\\\">private</span> def <span class=\\\"token function\\\">createBaseRdd</span><span class=\\\"token punctuation\\\">(</span>inputPaths<span class=\\\"token punctuation\\\">:</span> Array<span class=\\\"token punctuation\\\">[</span>String<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">:</span> RDD<span class=\\\"token punctuation\\\">[</span>String<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    val url <span class=\\\"token operator\\\">=</span> inputPaths<span class=\\\"token punctuation\\\">.</span>head\\n    val res <span class=\\\"token operator\\\">=</span> Request<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Get</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">URL</span><span class=\\\"token punctuation\\\">(</span>url<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>toURI<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">execute</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n    val response <span class=\\\"token operator\\\">=</span> res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">returnResponse</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n    val content <span class=\\\"token operator\\\">=</span> EntityUtils<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toString</span><span class=\\\"token punctuation\\\">(</span>response<span class=\\\"token punctuation\\\">.</span>getEntity<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>response <span class=\\\"token operator\\\">!=</span> <span class=\\\"token keyword\\\">null</span> <span class=\\\"token operator\\\">&amp;&amp;</span> response<span class=\\\"token punctuation\\\">.</span>getStatusLine<span class=\\\"token punctuation\\\">.</span>getStatusCode <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">200</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token comment\\\">//这里是做数据抽取的，把data的数组给抽取出来</span>\\n      <span class=\\\"token keyword\\\">import</span> scala<span class=\\\"token punctuation\\\">.</span>collection<span class=\\\"token punctuation\\\">.</span>JavaConversions<span class=\\\"token punctuation\\\">.</span>_\\n      val extractContent <span class=\\\"token operator\\\">=</span> JSONArray<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">fromObject</span><span class=\\\"token punctuation\\\">(</span>JSONPath<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">read</span><span class=\\\"token punctuation\\\">(</span>content<span class=\\\"token punctuation\\\">,</span> xPath<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>\\n        <span class=\\\"token function\\\">map</span><span class=\\\"token punctuation\\\">(</span>f <span class=\\\"token operator\\\">=></span> JSONObject<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">fromObject</span><span class=\\\"token punctuation\\\">(</span>f<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>toString<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>toSeq\\n      sqlContext<span class=\\\"token punctuation\\\">.</span>sparkContext<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">makeRDD</span><span class=\\\"token punctuation\\\">(</span>extractContent<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n      sqlContext<span class=\\\"token punctuation\\\">.</span>sparkContext<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">makeRDD</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Seq</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>有了这个类就能获取到数据，就可以做Schema推导了：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code> lazy val dataSchema <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n   <span class=\\\"token comment\\\">//我们也允许用户传递给我们Schema,如果没有就自己推导</span>\\n    val jsonSchema <span class=\\\"token operator\\\">=</span> maybeDataSchema<span class=\\\"token punctuation\\\">.</span>getOrElse <span class=\\\"token punctuation\\\">{</span>      \\n      <span class=\\\"token function\\\">InferSchema</span><span class=\\\"token punctuation\\\">(</span>\\n        <span class=\\\"token comment\\\">//拿到数据</span>\\n        inputRDD<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getOrElse</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">createBaseRdd</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Array</span><span class=\\\"token punctuation\\\">(</span>url<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n       <span class=\\\"token comment\\\">//采样率，其实就是拿sc.sample方法</span>\\n        samplingRatio<span class=\\\"token punctuation\\\">,</span>\\n        sqlContext<span class=\\\"token punctuation\\\">.</span>conf<span class=\\\"token punctuation\\\">.</span>columnNameOfCorruptRecord<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token function\\\">checkConstraints</span><span class=\\\"token punctuation\\\">(</span>jsonSchema<span class=\\\"token punctuation\\\">)</span>\\n\\n    jsonSchema\\n  <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>InferSchema的实现逻辑比较复杂，但最终就是为了返回StructType(fields: Array[StructField]) 这么个东西。我是直接拷贝的spark JSON DataSource的实现。有兴趣的可以自己参看。StructType其实也很简单了，无非就是一个描述Schema的结构，类似你定义一张表，你需要告诉系统字段名称，类型，是否为Null等一些列信息。</p>\\n<p>现在我们终于搞定了数据表结构了。</p>\\n<h2>数据获取</h2>\\n<p>刚才我们说了数据获取的四种类型，我们这里使用的是TableScan,继承自该接口只要实现一个buildScan方法就好：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>def <span class=\\\"token function\\\">buildScan</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">:</span> RDD<span class=\\\"token punctuation\\\">[</span>Row<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">JacksonParser</span><span class=\\\"token punctuation\\\">(</span>\\n      inputRDD<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getOrElse</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">createBaseRdd</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Array</span><span class=\\\"token punctuation\\\">(</span>url<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n      dataSchema<span class=\\\"token punctuation\\\">,</span>      sqlContext<span class=\\\"token punctuation\\\">.</span>conf<span class=\\\"token punctuation\\\">.</span>columnNameOfCorruptRecord<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>asInstanceOf<span class=\\\"token punctuation\\\">[</span>RDD<span class=\\\"token punctuation\\\">[</span>Row<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">]</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>其本质工作就是把JSON格式的String根据我们前面已经拿到的Schema转化为Row格式。</p>\\n<p>具体做法如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token comment\\\">//这个是createBaseRDD返回的RDD[String]</span>\\n<span class=\\\"token comment\\\">//对应的String 其实是JSON格式</span>\\n<span class=\\\"token comment\\\">//针对每个分区做处理</span>\\njson<span class=\\\"token punctuation\\\">.</span>mapPartitions <span class=\\\"token punctuation\\\">{</span> iter <span class=\\\"token operator\\\">=></span>\\n      val factory <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">JsonFactory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n      iter<span class=\\\"token punctuation\\\">.</span>flatMap <span class=\\\"token punctuation\\\">{</span> record <span class=\\\"token operator\\\">=></span>\\n        <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n          <span class=\\\"token comment\\\">//JSON的解析器</span>\\n          val parser <span class=\\\"token operator\\\">=</span> factory<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">createParser</span><span class=\\\"token punctuation\\\">(</span>record<span class=\\\"token punctuation\\\">)</span>\\n          parser<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">nextToken</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n         <span class=\\\"token comment\\\">//这里开始做类型转换了</span>\\n          <span class=\\\"token function\\\">convertField</span><span class=\\\"token punctuation\\\">(</span>factory<span class=\\\"token punctuation\\\">,</span> parser<span class=\\\"token punctuation\\\">,</span> schema<span class=\\\"token punctuation\\\">)</span> match <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">case</span> <span class=\\\"token keyword\\\">null</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token function\\\">failedRecord</span><span class=\\\"token punctuation\\\">(</span>record<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">case</span> row<span class=\\\"token punctuation\\\">:</span> InternalRow <span class=\\\"token operator\\\">=></span> row <span class=\\\"token punctuation\\\">:</span><span class=\\\"token punctuation\\\">:</span> Nil\\n            <span class=\\\"token keyword\\\">case</span> array<span class=\\\"token punctuation\\\">:</span> ArrayData <span class=\\\"token operator\\\">=></span>\\n              <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>array<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">numElements</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                Nil\\n              <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n                array<span class=\\\"token punctuation\\\">.</span>toArray<span class=\\\"token punctuation\\\">[</span>InternalRow<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">(</span>schema<span class=\\\"token punctuation\\\">)</span>\\n              <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">case</span> _ <span class=\\\"token operator\\\">=></span>\\n              sys<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">error</span><span class=\\\"token punctuation\\\">(</span>\\n                s<span class=\\\"token string\\\">\\\"Failed to parse record $record. Please make sure that each line of the file \\\"</span> <span class=\\\"token operator\\\">+</span>\\n                  <span class=\\\"token string\\\">\\\"(or each string in the RDD) is a valid JSON object or an array of JSON objects.\\\"</span><span class=\\\"token punctuation\\\">)</span>\\n          <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">{</span>\\n          <span class=\\\"token keyword\\\">case</span> _<span class=\\\"token punctuation\\\">:</span> JsonProcessingException <span class=\\\"token operator\\\">=></span>\\n            <span class=\\\"token function\\\">failedRecord</span><span class=\\\"token punctuation\\\">(</span>record<span class=\\\"token punctuation\\\">)</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n      <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>这里的代码还是比较清晰易懂的。但是 convertField(factory, parser, schema) 直接match 到  InternalRow 还是比较让人困惑的，一个字段转换咋就变成了InternalRow了呢？这里确实也有乾坤的。我们进去看看convertField方法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code> <span class=\\\"token keyword\\\">private</span><span class=\\\"token punctuation\\\">[</span>sql<span class=\\\"token punctuation\\\">]</span> def <span class=\\\"token function\\\">convertField</span><span class=\\\"token punctuation\\\">(</span>\\n      factory<span class=\\\"token punctuation\\\">:</span> JsonFactory<span class=\\\"token punctuation\\\">,</span>\\n      parser<span class=\\\"token punctuation\\\">:</span> JsonParser<span class=\\\"token punctuation\\\">,</span>\\n      schema<span class=\\\"token punctuation\\\">:</span> DataType<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">:</span> Any <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">import</span> com<span class=\\\"token punctuation\\\">.</span>fasterxml<span class=\\\"token punctuation\\\">.</span>jackson<span class=\\\"token punctuation\\\">.</span>core<span class=\\\"token punctuation\\\">.</span>JsonToken<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">_</span>\\n    <span class=\\\"token punctuation\\\">(</span>parser<span class=\\\"token punctuation\\\">.</span>getCurrentToken<span class=\\\"token punctuation\\\">,</span> schema<span class=\\\"token punctuation\\\">)</span> match <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">case</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">null</span> <span class=\\\"token operator\\\">|</span> VALUE_NULL<span class=\\\"token punctuation\\\">,</span> _<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span>\\n        <span class=\\\"token keyword\\\">null</span>\\n\\n      <span class=\\\"token keyword\\\">case</span> <span class=\\\"token punctuation\\\">(</span>FIELD_NAME<span class=\\\"token punctuation\\\">,</span> _<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span>\\n        parser<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">nextToken</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n        <span class=\\\"token function\\\">convertField</span><span class=\\\"token punctuation\\\">(</span>factory<span class=\\\"token punctuation\\\">,</span> parser<span class=\\\"token punctuation\\\">,</span> schema<span class=\\\"token punctuation\\\">)</span>\\n\\n     <span class=\\\"token operator\\\">...</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span>\\n     <span class=\\\"token keyword\\\">case</span> <span class=\\\"token punctuation\\\">(</span>START_OBJECT<span class=\\\"token punctuation\\\">,</span> st<span class=\\\"token punctuation\\\">:</span> StructType<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span>  \\n       <span class=\\\"token function\\\">convertObject</span><span class=\\\"token punctuation\\\">(</span>factory<span class=\\\"token punctuation\\\">,</span> parser<span class=\\\"token punctuation\\\">,</span> st<span class=\\\"token punctuation\\\">)</span>\\n</code></pre>\\n      </div>\\n<p>如果你的JSON是个Map,经过N次匹配case后会进入最后一个case 情况。这里的st:StructType 就是我们之前自己推导出来的dataSchema. convertObject 方法如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code> <span class=\\\"token keyword\\\">while</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">nextUntil</span><span class=\\\"token punctuation\\\">(</span>parser<span class=\\\"token punctuation\\\">,</span> JsonToken<span class=\\\"token punctuation\\\">.</span>END_OBJECT<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      schema<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getFieldIndex</span><span class=\\\"token punctuation\\\">(</span>parser<span class=\\\"token punctuation\\\">.</span>getCurrentName<span class=\\\"token punctuation\\\">)</span> match <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">case</span> <span class=\\\"token function\\\">Some</span><span class=\\\"token punctuation\\\">(</span>index<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span>\\n          row<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">update</span><span class=\\\"token punctuation\\\">(</span>index<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token function\\\">convertField</span><span class=\\\"token punctuation\\\">(</span>factory<span class=\\\"token punctuation\\\">,</span> parser<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token function\\\">schema</span><span class=\\\"token punctuation\\\">(</span>index<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>dataType<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n\\n        <span class=\\\"token keyword\\\">case</span> None <span class=\\\"token operator\\\">=></span>\\n          parser<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">skipChildren</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n      <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>到这里就真相大白了。为了能够拿到一条完整的数据，他会while循环直到遇到END<em>OBJECT 。所谓END</em>OBJECT 其实就是一个Map 结束了。 在每一次循环里，拿到一个字段，然后通过名字去schema里获取类型信息，然后再回调convertField方法将这个字段转化为row需要的类型，比如字符串类型的就通过UTF8String进行转换。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>case (VALUE_STRING, StringType) =>  UTF8String.fromString(parser.getText)</code></pre>\\n      </div>\\n<p>得到的值通过Row的函数进行更新,这里是 row.update 方法。到END_OBJECT后，就完成了将一个JSON Map 转化为一条Row的功能了。</p>\\n<h2>收工</h2>\\n<p>到目前为止，我们已经完成了具体的工作了。现在你已经可以按如下的方式使用：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>val df <span class=\\\"token operator\\\">=</span> SQLContext<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getOrCreate</span><span class=\\\"token punctuation\\\">(</span>sc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>\\nread<span class=\\\"token punctuation\\\">.</span>\\n<span class=\\\"token function\\\">format</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"org.apache.spark.sql.execution.datasources.rest.json\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token comment\\\">//驱动程序，类似JDBC的 driver class </span>\\n<span class=\\\"token function\\\">options</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Map</span><span class=\\\"token punctuation\\\">(</span>\\n<span class=\\\"token string\\\">\\\"url\\\"</span><span class=\\\"token operator\\\">-</span><span class=\\\"token operator\\\">></span><span class=\\\"token string\\\">\\\"http://[your dns]/path\\\"</span>\\n<span class=\\\"token string\\\">\\\"xPath\\\"</span> <span class=\\\"token operator\\\">-</span><span class=\\\"token operator\\\">></span> <span class=\\\"token string\\\">\\\"$.data\\\"</span>\\n<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span> <span class=\\\"token comment\\\">//你需要额外传递给驱动的参数</span>\\n<span class=\\\"token function\\\">load</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"url\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//资源路径</span>\\n</code></pre>\\n      </div>\\n<p>获取到的Dataframe 你可以做任意的操作。</p>\\n<h2>总结</h2>\\n<p>Spark DataSource API的提出，给Spark 构建生态带来了巨大的好处。各个存储系统可以实现统一标准的接口去对接Spark。学会使用自己实现一个DataSoure是的你的存储可以更好的和生态结合，也能得到更好的性能优化。</p>\"},\"indexJson\":{\"title\":\"利用-Spark-DataSource-API-实现Rest数据源\"}},\"pathContext\":{\"slug\":\"/posts/3/\",\"pid\":3,\"next\":\"/posts/4\",\"prev\":\"/posts/2\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-3-65ce2f5b9207722d610a.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p> Spark DataSource API 的提出使得各个数据源按规范实现适配，那么就可以高效的利用Spark 的计算能力。典型如Parquet,CarbonData,Postgrep(JDBC类的都OK)等实现。本文则介绍如何利用Spark DataSource 对标准Rest接口实现读取</p>\\n</blockquote>\\n<h2>引子</h2>\\n<p>先说下这个需求的来源。通常在一个流式计算的主流程里，会用到很多映射数据，譬如某某对照关系，而这些映射数据通常是通过HTTP接口暴露出来的,尤其是外部系统，你基本没有办法直接通过JDBC去读库啥的。</p>\\n<p>上面是一个点，其次是从HTTP读到的JSON数据，我其实需要做扁平化处理的。现在如果SQL作用于JSON数据可以解决简单的嵌套问题，但是更复杂的方式是没有太大办法的。</p>\\n<p>比如下面格式的：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>{\\n  \\\"status\\\":\\\"200\\\",\\n  \\\"data\\\":[\\n   \\\"id\\\":1,\\n   \\\"userid\\\":2,\\n   \\\"service\\\":{\\n    \\\"3\\\":{\\\"a\\\":1,\\\"b\\\":2},\\n    \\\"2\\\":{\\\"a\\\":3,\\\"b\\\":2},\\n    .....\\n  }\\n\\n]\\n}</code></pre>\\n      </div>\\n<p>最好能展开成这种格式才能够被主流程直接join使用：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code> {id:1,userid:2,service:3,a:1,b:2}\\n {id:1,userid:2,service:2,a:3,b:2}</code></pre>\\n      </div>\\n<p>所以为了实现同事的需求，我需要第一将Rest接口的获取方式用标准的DataSource API 来实现，其次提供一个能够做如上合并规则的模块，并且允许配置。</p>\\n<p>最后实现的效果参看： <a href=\\\"https://gist.github.com/allwefantasy/42fd5afa2dc76f7bcc56e9e72977eaa3\\\">Rest DataSource</a></p>\\n<p>实现代码可以参看：<a href=\\\"https://github.com/allwefantasy/streamingpro/tree/master/src/main/java/org/apache/spark/sql/execution/datasources/rest/json\\\">RestJSONDataSource</a></p>\\n<h2>实现目标</h2>\\n<p>先看看DataSource API 的样子：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>val df <span class=\\\"token operator\\\">=</span> SQLContext<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getOrCreate</span><span class=\\\"token punctuation\\\">(</span>sc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>\\nread<span class=\\\"token punctuation\\\">.</span>\\n<span class=\\\"token function\\\">format</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"driver class\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token comment\\\">//驱动程序，类似JDBC的 driver class </span>\\n<span class=\\\"token function\\\">options</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Map</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">...</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span> <span class=\\\"token comment\\\">//你需要额外传递给驱动的参数</span>\\n<span class=\\\"token function\\\">load</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"url\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//资源路径</span>\\n</code></pre>\\n      </div>\\n<p>如果做成配置化则是：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token string\\\">\\\"name\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">\\\"streaming.core.compositor.spark.source.SQLSourceCompositor\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n        <span class=\\\"token string\\\">\\\"params\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">[</span>\\n          <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token string\\\">\\\"format\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">\\\"org.apache.spark.sql.execution.datasources.rest.json\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n            <span class=\\\"token string\\\">\\\"url\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">\\\"http://[your dns]/path\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n            <span class=\\\"token string\\\">\\\"xPath\\\"</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">\\\"$.data\\\"</span>\\n          <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">]</span>\\n      <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<h2>DefaultSource的实现</h2>\\n<p>定义</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>org.apache.spark.sql.execution.datasources.rest.json.DefaultSource\\nextends RelationProvider \\nwith DataSourceRegister</code></pre>\\n      </div>\\n<p>这是比较典型的命名规范。rest 代表支持的是rest作为接口，json则代表rest接口的数据是json格式的，包的命名让人一目了然。</p>\\n<p>先看看DefaultSource继承的两个接口</p>\\n<ul>\\n<li>DataSourceRegister</li>\\n</ul>\\n<p>该接口只有一个<code>shortName</code> 方法。我们看到上面的包名是很长的，你可以给一个更简短的名字：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>org.apache.spark.sql.execution.datasources.rest.json \\n==>\\nrestJSON</code></pre>\\n      </div>\\n<p>所以具体实现就变成了：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>override def shortName(): String = \\\"restJSON\\\"</code></pre>\\n      </div>\\n<ul>\\n<li>RelationProvider</li>\\n</ul>\\n<p>这个接口也只有一个方法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>def createRelation(sqlContext: SQLContext, parameters: Map[String, String]): BaseRelation</code></pre>\\n      </div>\\n<p>其返回值BaseRelation对象描述了数据源和Spark SQL交互。createRelation方法允许你根据用户定义的参数<code>parameters</code> 创建一个合适的BaseRelation的实现类。</p>\\n<p>其实除了这个，还有一些携带更多信息的继承自RelationProvider的类，譬如：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>SchemaRelationProvider 允许你直接传递Schema信息给BaseRelation实现。\\nHadoopFsRelationProvider  除了参数帮你加了path等，返回值也帮你约定成HadoopFsRelation. HadoopFsRelation 提供了和HDFS交互的大部分实现</code></pre>\\n      </div>\\n<p>在我们的实现里，只要实现基础的RelationProvider就好。</p>\\n<p>我们来看下DefaultSource.createRelation的具体代码：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>override def createRelation(\\n                               sqlContext: SQLContext,\\n                               //还记的DataSource的options方法么，parameters就是\\n                               //用户通过options传递过来的\\n                               parameters: Map[String, String]\\n                               ): BaseRelation = {\\n//因为我们并需要用户提供schema\\n//而是从JSON格式数据自己自己推导出来的\\n// 所以这里有个采样率的概念\\n    val samplingRatio = parameters.get(\\\"samplingRatio\\\").map(_.toDouble).getOrElse(1.0)\\n// 还记得DataSource的 path么？ 理论上是应该通过那个传递过来的，然而\\n//这里是直接通过potions传递过来的。\\n    val url = parameters.getOrElse(\\\"url\\\", \\\"\\\")\\n// 我们需要能够对通过XPATH语法抽取我们要的数据，比如\\n//前面的例子，我们需要能够抽取出data那个数组\\n    val xPath = parameters.getOrElse(\\\"xPath\\\", \\\"$\\\")\\n   //这里是核心\\n    new RestJSONRelation(None, url, xPath, samplingRatio, None)(sqlContext)\\n  }</code></pre>\\n      </div>\\n<p>源码中已经做了说明。这里RestJSONRelation是整个核心，它实现了Spark SQL 和数据源的交互。RestJSONRelation继承自BaseRelation，TableScan等基类</p>\\n<h2>RestJSONRelation</h2>\\n<p>先看看RestJSONRelation 的签名：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">private</span><span class=\\\"token punctuation\\\">[</span>sql<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">RestJSONRelation</span><span class=\\\"token punctuation\\\">(</span>\\n                           val inputRDD<span class=\\\"token punctuation\\\">:</span> Option<span class=\\\"token punctuation\\\">[</span>RDD<span class=\\\"token punctuation\\\">[</span>String<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span>\\n                           val url<span class=\\\"token punctuation\\\">:</span> String<span class=\\\"token punctuation\\\">,</span>\\n                           val xPath<span class=\\\"token punctuation\\\">:</span> String<span class=\\\"token punctuation\\\">,</span>\\n                           val samplingRatio<span class=\\\"token punctuation\\\">:</span> Double<span class=\\\"token punctuation\\\">,</span>\\n                           val maybeDataSchema<span class=\\\"token punctuation\\\">:</span> Option<span class=\\\"token punctuation\\\">[</span>StructType<span class=\\\"token punctuation\\\">]</span>\\n                           <span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">(</span>@transient val sqlContext<span class=\\\"token punctuation\\\">:</span> SQLContext<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">BaseRelation</span> <span class=\\\"token keyword\\\">with</span> TableScan <span class=\\\"token punctuation\\\">{</span>\\n</code></pre>\\n      </div>\\n<p>这些参数是你随便定义的。当然，url,xPath,smaplingRatio具体的含义在上一章节都提到了。</p>\\n<p>和数据源进行交互有两个必要的信息需要获取：</p>\\n<ul>\\n<li>\\n<p>Schema 信息。只有两种方法：用户告知你，或者程序自己根据数据推导。关于schema信息这块，BaseRelation还提供了几个基础的约定：</p>\\n<ul>\\n<li>needConversion，是否需类型转换，因为Spark SQL内部的表示是Row,里面的数据需要特定的类型，比如String会被转化成UTF8String。默认为true,官方也是说不要管他就好。</li>\\n<li>unhandledFilters, 返回一些数据源没有办法pushdown的filter。这样解析器就知道可以在Spark内部做filter了。否则Spark 会傻傻的以为你做了过滤，然后数据计算结果就错了。</li>\\n</ul>\\n</li>\\n<li>\\n<p>数据扫描的方法。 目前Spark SQL 提供了四种</p>\\n<ul>\\n<li>TableScan 全表扫描</li>\\n<li>PrunedScan  可以指定列，其他的列数据源可以不用返回</li>\\n<li>PrunedFilteredScan 指定列，并且还可以加一些过滤条件，只返回满足条件的数据。这个也就是我们常说的数据源<code>下沉(pushdown)</code>操作。</li>\\n<li>CatalystScan 和PrunedFilteredScan类似，支持列过滤，数据过滤，但是接受的过滤条件是Spark 里的Expression。 理论上会更灵活些。话说在Spark源码)里(1.6.1版本)，我没有看到这个类的具体实现案例。\\n这里我们只要实现一个简单的TableScan就可以了，因为拿的是字典数据，并不需要做过滤。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Schema推导</h2>\\n<p>BaseRelation是需要你给出Schema的。这里我们会先定义一个dataSchema的lazy属性，这样防止schema方法被反复调用而反复推导。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>override def schema: StructType = dataSchema\\nlazy val dataSchema = .....</code></pre>\\n      </div>\\n<p>因为我们是根据数据推导Schema,所以首先要获取数据。我们定义一个方法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>private def createBaseRdd(inputPaths: Array[String]): RDD[String]</code></pre>\\n      </div>\\n<p>inputPaths 我沿用了文件系统的概念，其实在我们这里就是一个URL。我们知道，最终Spark SQL 的直接数据源都是RDD的。所以这里我们返回的也是RDD[String]类型。具体实现很简单，就是通过HttpClient根据inputPaths拿到数据之后makeRDD一下就可以了。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token comment\\\">//应该要再加个重试机制就更好了</span>\\n<span class=\\\"token keyword\\\">private</span> def <span class=\\\"token function\\\">createBaseRdd</span><span class=\\\"token punctuation\\\">(</span>inputPaths<span class=\\\"token punctuation\\\">:</span> Array<span class=\\\"token punctuation\\\">[</span>String<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">:</span> RDD<span class=\\\"token punctuation\\\">[</span>String<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    val url <span class=\\\"token operator\\\">=</span> inputPaths<span class=\\\"token punctuation\\\">.</span>head\\n    val res <span class=\\\"token operator\\\">=</span> Request<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Get</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">URL</span><span class=\\\"token punctuation\\\">(</span>url<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>toURI<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">execute</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n    val response <span class=\\\"token operator\\\">=</span> res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">returnResponse</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n    val content <span class=\\\"token operator\\\">=</span> EntityUtils<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toString</span><span class=\\\"token punctuation\\\">(</span>response<span class=\\\"token punctuation\\\">.</span>getEntity<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>response <span class=\\\"token operator\\\">!=</span> <span class=\\\"token keyword\\\">null</span> <span class=\\\"token operator\\\">&amp;&amp;</span> response<span class=\\\"token punctuation\\\">.</span>getStatusLine<span class=\\\"token punctuation\\\">.</span>getStatusCode <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">200</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token comment\\\">//这里是做数据抽取的，把data的数组给抽取出来</span>\\n      <span class=\\\"token keyword\\\">import</span> scala<span class=\\\"token punctuation\\\">.</span>collection<span class=\\\"token punctuation\\\">.</span>JavaConversions<span class=\\\"token punctuation\\\">.</span>_\\n      val extractContent <span class=\\\"token operator\\\">=</span> JSONArray<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">fromObject</span><span class=\\\"token punctuation\\\">(</span>JSONPath<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">read</span><span class=\\\"token punctuation\\\">(</span>content<span class=\\\"token punctuation\\\">,</span> xPath<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>\\n        <span class=\\\"token function\\\">map</span><span class=\\\"token punctuation\\\">(</span>f <span class=\\\"token operator\\\">=></span> JSONObject<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">fromObject</span><span class=\\\"token punctuation\\\">(</span>f<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>toString<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>toSeq\\n      sqlContext<span class=\\\"token punctuation\\\">.</span>sparkContext<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">makeRDD</span><span class=\\\"token punctuation\\\">(</span>extractContent<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n      sqlContext<span class=\\\"token punctuation\\\">.</span>sparkContext<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">makeRDD</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Seq</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>有了这个类就能获取到数据，就可以做Schema推导了：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code> lazy val dataSchema <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n   <span class=\\\"token comment\\\">//我们也允许用户传递给我们Schema,如果没有就自己推导</span>\\n    val jsonSchema <span class=\\\"token operator\\\">=</span> maybeDataSchema<span class=\\\"token punctuation\\\">.</span>getOrElse <span class=\\\"token punctuation\\\">{</span>      \\n      <span class=\\\"token function\\\">InferSchema</span><span class=\\\"token punctuation\\\">(</span>\\n        <span class=\\\"token comment\\\">//拿到数据</span>\\n        inputRDD<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getOrElse</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">createBaseRdd</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Array</span><span class=\\\"token punctuation\\\">(</span>url<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n       <span class=\\\"token comment\\\">//采样率，其实就是拿sc.sample方法</span>\\n        samplingRatio<span class=\\\"token punctuation\\\">,</span>\\n        sqlContext<span class=\\\"token punctuation\\\">.</span>conf<span class=\\\"token punctuation\\\">.</span>columnNameOfCorruptRecord<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token function\\\">checkConstraints</span><span class=\\\"token punctuation\\\">(</span>jsonSchema<span class=\\\"token punctuation\\\">)</span>\\n\\n    jsonSchema\\n  <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>InferSchema的实现逻辑比较复杂，但最终就是为了返回StructType(fields: Array[StructField]) 这么个东西。我是直接拷贝的spark JSON DataSource的实现。有兴趣的可以自己参看。StructType其实也很简单了，无非就是一个描述Schema的结构，类似你定义一张表，你需要告诉系统字段名称，类型，是否为Null等一些列信息。</p>\\n<p>现在我们终于搞定了数据表结构了。</p>\\n<h2>数据获取</h2>\\n<p>刚才我们说了数据获取的四种类型，我们这里使用的是TableScan,继承自该接口只要实现一个buildScan方法就好：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>def <span class=\\\"token function\\\">buildScan</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">:</span> RDD<span class=\\\"token punctuation\\\">[</span>Row<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">JacksonParser</span><span class=\\\"token punctuation\\\">(</span>\\n      inputRDD<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getOrElse</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">createBaseRdd</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Array</span><span class=\\\"token punctuation\\\">(</span>url<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n      dataSchema<span class=\\\"token punctuation\\\">,</span>      sqlContext<span class=\\\"token punctuation\\\">.</span>conf<span class=\\\"token punctuation\\\">.</span>columnNameOfCorruptRecord<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>asInstanceOf<span class=\\\"token punctuation\\\">[</span>RDD<span class=\\\"token punctuation\\\">[</span>Row<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">]</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>其本质工作就是把JSON格式的String根据我们前面已经拿到的Schema转化为Row格式。</p>\\n<p>具体做法如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token comment\\\">//这个是createBaseRDD返回的RDD[String]</span>\\n<span class=\\\"token comment\\\">//对应的String 其实是JSON格式</span>\\n<span class=\\\"token comment\\\">//针对每个分区做处理</span>\\njson<span class=\\\"token punctuation\\\">.</span>mapPartitions <span class=\\\"token punctuation\\\">{</span> iter <span class=\\\"token operator\\\">=></span>\\n      val factory <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">JsonFactory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n      iter<span class=\\\"token punctuation\\\">.</span>flatMap <span class=\\\"token punctuation\\\">{</span> record <span class=\\\"token operator\\\">=></span>\\n        <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n          <span class=\\\"token comment\\\">//JSON的解析器</span>\\n          val parser <span class=\\\"token operator\\\">=</span> factory<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">createParser</span><span class=\\\"token punctuation\\\">(</span>record<span class=\\\"token punctuation\\\">)</span>\\n          parser<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">nextToken</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n         <span class=\\\"token comment\\\">//这里开始做类型转换了</span>\\n          <span class=\\\"token function\\\">convertField</span><span class=\\\"token punctuation\\\">(</span>factory<span class=\\\"token punctuation\\\">,</span> parser<span class=\\\"token punctuation\\\">,</span> schema<span class=\\\"token punctuation\\\">)</span> match <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">case</span> <span class=\\\"token keyword\\\">null</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token function\\\">failedRecord</span><span class=\\\"token punctuation\\\">(</span>record<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">case</span> row<span class=\\\"token punctuation\\\">:</span> InternalRow <span class=\\\"token operator\\\">=></span> row <span class=\\\"token punctuation\\\">:</span><span class=\\\"token punctuation\\\">:</span> Nil\\n            <span class=\\\"token keyword\\\">case</span> array<span class=\\\"token punctuation\\\">:</span> ArrayData <span class=\\\"token operator\\\">=></span>\\n              <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>array<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">numElements</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                Nil\\n              <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n                array<span class=\\\"token punctuation\\\">.</span>toArray<span class=\\\"token punctuation\\\">[</span>InternalRow<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">(</span>schema<span class=\\\"token punctuation\\\">)</span>\\n              <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">case</span> _ <span class=\\\"token operator\\\">=></span>\\n              sys<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">error</span><span class=\\\"token punctuation\\\">(</span>\\n                s<span class=\\\"token string\\\">\\\"Failed to parse record $record. Please make sure that each line of the file \\\"</span> <span class=\\\"token operator\\\">+</span>\\n                  <span class=\\\"token string\\\">\\\"(or each string in the RDD) is a valid JSON object or an array of JSON objects.\\\"</span><span class=\\\"token punctuation\\\">)</span>\\n          <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">{</span>\\n          <span class=\\\"token keyword\\\">case</span> _<span class=\\\"token punctuation\\\">:</span> JsonProcessingException <span class=\\\"token operator\\\">=></span>\\n            <span class=\\\"token function\\\">failedRecord</span><span class=\\\"token punctuation\\\">(</span>record<span class=\\\"token punctuation\\\">)</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n      <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>这里的代码还是比较清晰易懂的。但是 convertField(factory, parser, schema) 直接match 到  InternalRow 还是比较让人困惑的，一个字段转换咋就变成了InternalRow了呢？这里确实也有乾坤的。我们进去看看convertField方法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code> <span class=\\\"token keyword\\\">private</span><span class=\\\"token punctuation\\\">[</span>sql<span class=\\\"token punctuation\\\">]</span> def <span class=\\\"token function\\\">convertField</span><span class=\\\"token punctuation\\\">(</span>\\n      factory<span class=\\\"token punctuation\\\">:</span> JsonFactory<span class=\\\"token punctuation\\\">,</span>\\n      parser<span class=\\\"token punctuation\\\">:</span> JsonParser<span class=\\\"token punctuation\\\">,</span>\\n      schema<span class=\\\"token punctuation\\\">:</span> DataType<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">:</span> Any <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">import</span> com<span class=\\\"token punctuation\\\">.</span>fasterxml<span class=\\\"token punctuation\\\">.</span>jackson<span class=\\\"token punctuation\\\">.</span>core<span class=\\\"token punctuation\\\">.</span>JsonToken<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">_</span>\\n    <span class=\\\"token punctuation\\\">(</span>parser<span class=\\\"token punctuation\\\">.</span>getCurrentToken<span class=\\\"token punctuation\\\">,</span> schema<span class=\\\"token punctuation\\\">)</span> match <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">case</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">null</span> <span class=\\\"token operator\\\">|</span> VALUE_NULL<span class=\\\"token punctuation\\\">,</span> _<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span>\\n        <span class=\\\"token keyword\\\">null</span>\\n\\n      <span class=\\\"token keyword\\\">case</span> <span class=\\\"token punctuation\\\">(</span>FIELD_NAME<span class=\\\"token punctuation\\\">,</span> _<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span>\\n        parser<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">nextToken</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n        <span class=\\\"token function\\\">convertField</span><span class=\\\"token punctuation\\\">(</span>factory<span class=\\\"token punctuation\\\">,</span> parser<span class=\\\"token punctuation\\\">,</span> schema<span class=\\\"token punctuation\\\">)</span>\\n\\n     <span class=\\\"token operator\\\">...</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span>\\n     <span class=\\\"token keyword\\\">case</span> <span class=\\\"token punctuation\\\">(</span>START_OBJECT<span class=\\\"token punctuation\\\">,</span> st<span class=\\\"token punctuation\\\">:</span> StructType<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span>  \\n       <span class=\\\"token function\\\">convertObject</span><span class=\\\"token punctuation\\\">(</span>factory<span class=\\\"token punctuation\\\">,</span> parser<span class=\\\"token punctuation\\\">,</span> st<span class=\\\"token punctuation\\\">)</span>\\n</code></pre>\\n      </div>\\n<p>如果你的JSON是个Map,经过N次匹配case后会进入最后一个case 情况。这里的st:StructType 就是我们之前自己推导出来的dataSchema. convertObject 方法如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code> <span class=\\\"token keyword\\\">while</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">nextUntil</span><span class=\\\"token punctuation\\\">(</span>parser<span class=\\\"token punctuation\\\">,</span> JsonToken<span class=\\\"token punctuation\\\">.</span>END_OBJECT<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      schema<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getFieldIndex</span><span class=\\\"token punctuation\\\">(</span>parser<span class=\\\"token punctuation\\\">.</span>getCurrentName<span class=\\\"token punctuation\\\">)</span> match <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">case</span> <span class=\\\"token function\\\">Some</span><span class=\\\"token punctuation\\\">(</span>index<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span>\\n          row<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">update</span><span class=\\\"token punctuation\\\">(</span>index<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token function\\\">convertField</span><span class=\\\"token punctuation\\\">(</span>factory<span class=\\\"token punctuation\\\">,</span> parser<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token function\\\">schema</span><span class=\\\"token punctuation\\\">(</span>index<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>dataType<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n\\n        <span class=\\\"token keyword\\\">case</span> None <span class=\\\"token operator\\\">=></span>\\n          parser<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">skipChildren</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n      <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>到这里就真相大白了。为了能够拿到一条完整的数据，他会while循环直到遇到END<em>OBJECT 。所谓END</em>OBJECT 其实就是一个Map 结束了。 在每一次循环里，拿到一个字段，然后通过名字去schema里获取类型信息，然后再回调convertField方法将这个字段转化为row需要的类型，比如字符串类型的就通过UTF8String进行转换。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>case (VALUE_STRING, StringType) =>  UTF8String.fromString(parser.getText)</code></pre>\\n      </div>\\n<p>得到的值通过Row的函数进行更新,这里是 row.update 方法。到END_OBJECT后，就完成了将一个JSON Map 转化为一条Row的功能了。</p>\\n<h2>收工</h2>\\n<p>到目前为止，我们已经完成了具体的工作了。现在你已经可以按如下的方式使用：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>val df <span class=\\\"token operator\\\">=</span> SQLContext<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getOrCreate</span><span class=\\\"token punctuation\\\">(</span>sc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>\\nread<span class=\\\"token punctuation\\\">.</span>\\n<span class=\\\"token function\\\">format</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"org.apache.spark.sql.execution.datasources.rest.json\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token comment\\\">//驱动程序，类似JDBC的 driver class </span>\\n<span class=\\\"token function\\\">options</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">Map</span><span class=\\\"token punctuation\\\">(</span>\\n<span class=\\\"token string\\\">\\\"url\\\"</span><span class=\\\"token operator\\\">-</span><span class=\\\"token operator\\\">></span><span class=\\\"token string\\\">\\\"http://[your dns]/path\\\"</span>\\n<span class=\\\"token string\\\">\\\"xPath\\\"</span> <span class=\\\"token operator\\\">-</span><span class=\\\"token operator\\\">></span> <span class=\\\"token string\\\">\\\"$.data\\\"</span>\\n<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span> <span class=\\\"token comment\\\">//你需要额外传递给驱动的参数</span>\\n<span class=\\\"token function\\\">load</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"url\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//资源路径</span>\\n</code></pre>\\n      </div>\\n<p>获取到的Dataframe 你可以做任意的操作。</p>\\n<h2>总结</h2>\\n<p>Spark DataSource API的提出，给Spark 构建生态带来了巨大的好处。各个存储系统可以实现统一标准的接口去对接Spark。学会使用自己实现一个DataSoure是的你的存储可以更好的和生态结合，也能得到更好的性能优化。</p>\"},\"indexJson\":{\"title\":\"利用-Spark-DataSource-API-实现Rest数据源\"}},\"pathContext\":{\"slug\":\"/posts/3/\",\"pid\":3,\"next\":\"/posts/4\",\"prev\":\"/posts/2\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-3.json\n// module id = 362\n// module chunks = 81878219163735"],"sourceRoot":""}