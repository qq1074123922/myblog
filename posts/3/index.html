<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="shortcut icon" type="image/png" href="data:image/png;base64,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"/><link rel="preload" href="/myblog/component---src-layouts-index-js-9cceca90a718de9700cd.js" as="script"/><link rel="preload" href="/myblog/component---src-templates-blog-post-js-55b2a1a99d1ea213b953.js" as="script"/><link rel="preload" href="/myblog/path---posts-3-65ce2f5b9207722d610a.js" as="script"/><link rel="preload" href="/myblog/app-aaa42b203e53ba4b4de7.js" as="script"/><link rel="preload" href="/myblog/commons-68aad81503ae45628ade.js" as="script"/><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-aaa42b203e53ba4b4de7.js","107818501498521":"component---src-templates-blog-post-js-55b2a1a99d1ea213b953.js","263791100135453":"component---src-pages-about-js-ff45d29fd778b5a39075.js","35783957827783":"component---src-pages-index-js-31d5d9c1c3bd56028ef0.js","60335399758886":"path----557518bd178906f8d58a.js","91246642375014":"path---posts-1-90166e225d03eda6390c.js","216243879586913":"path---posts-2-f92f30ac7d2d8cb243fe.js","142656853184902":"path---posts-10-660bb478f0dd0283a544.js","244307437753867":"path---posts-11-64142ec9824c2a7d7728.js","81878219163735":"path---posts-3-65ce2f5b9207722d610a.js","279941687692024":"path---posts-12-3f9ea3d4d59f59f6b1ee.js","12712639087417":"path---posts-13-72fdb549041284013dc5.js","130752015456929":"path---posts-7-f6ed77d92a2e941ca489.js","123118983598882":"path---posts-4-a4e48f0959469d2db888.js","4876863402267":"path---posts-5-1c348bc4f0bbbffb828e.js","106140644916941":"path---posts-6-654c88b5731d540ed597.js","93923592088315":"path---posts-8-7cce6f2a475c28aa3699.js","20147626466865":"path---posts-9-b20d26b952031219dcce.js","273950069227526":"path---about-a0e39f21c11f6a62c5ab.js","142629428675168":"path---index-e44882bdf4cd02f99a8d.js","114276838955818":"component---src-layouts-index-js-9cceca90a718de9700cd.js"}/*]]>*/</script><style type="text/css" data-styled-components="kNnBpQ iKSQLe djlcST ZZrCW cDUvTM iLZaUK jorVQO" data-styled-components-is-local="true">/* sc-component-id: sc-bdVaJa */

.kNnBpQ{height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}
/* sc-component-id: sc-bwzfXH */

.djlcST{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;position:relative;}
/* sc-component-id: sc-htpNat */

.ZZrCW{position:absolute;top:0;left:0;right:0;bottom:0;}
/* sc-component-id: sc-bxivhb */

.iKSQLe{line-height:40px;padding:10px;background:#00bcd4;}.iKSQLe a{color:white;}
/* sc-component-id: sc-ifAKCX */

.jorVQO{background:#00bcd4;padding:28px;color:white;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}.jorVQO a{color:white;display:block;padding:0px;}
/* sc-component-id: sc-EHOje */

.cDUvTM{height:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;padding-top:20px;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.cDUvTM .markdown-content{padding:20px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}
/* sc-component-id: sc-bZQynM */

.iLZaUK{font-size:20px;text-align:center;font-weight:600px;}
</style><script>/*<![CDATA[*/!function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",["/myblog/commons-68aad81503ae45628ade.js","/myblog/app-aaa42b203e53ba4b4de7.js","/myblog/path---posts-3-65ce2f5b9207722d610a.js","/myblog/component---src-templates-blog-post-js-55b2a1a99d1ea213b953.js","/myblog/component---src-layouts-index-js-9cceca90a718de9700cd.js"])/*]]>*/</script><style id="gatsby-inlined-css">code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}body{margin:0}a{text-decoration:none}*{box-sizing:border-box}</style></head><body><div id="___gatsby"><div class="sc-bdVaJa kNnBpQ" data-reactroot="" data-reactid="1" data-react-checksum="1778645258"><div class="sc-bxivhb iKSQLe" data-reactid="2"><a href="/myblog/" data-reactid="3">首页</a></div><div class="sc-bwzfXH djlcST" data-reactid="4"><div class="sc-htpNat ZZrCW" data-reactid="5"><div class="sc-EHOje cDUvTM" data-reactid="6"><!-- react-empty: 7 --><div class="sc-bZQynM iLZaUK" data-reactid="8">利用-Spark-DataSource-API-实现Rest数据源</div><div class="markdown-content" data-reactid="9"><blockquote>
<p> Spark DataSource API 的提出使得各个数据源按规范实现适配，那么就可以高效的利用Spark 的计算能力。典型如Parquet,CarbonData,Postgrep(JDBC类的都OK)等实现。本文则介绍如何利用Spark DataSource 对标准Rest接口实现读取</p>
</blockquote>
<h2>引子</h2>
<p>先说下这个需求的来源。通常在一个流式计算的主流程里，会用到很多映射数据，譬如某某对照关系，而这些映射数据通常是通过HTTP接口暴露出来的,尤其是外部系统，你基本没有办法直接通过JDBC去读库啥的。</p>
<p>上面是一个点，其次是从HTTP读到的JSON数据，我其实需要做扁平化处理的。现在如果SQL作用于JSON数据可以解决简单的嵌套问题，但是更复杂的方式是没有太大办法的。</p>
<p>比如下面格式的：</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>{
  "status":"200",
  "data":[
   "id":1,
   "userid":2,
   "service":{
    "3":{"a":1,"b":2},
    "2":{"a":3,"b":2},
    .....
  }

]
}</code></pre>
      </div>
<p>最好能展开成这种格式才能够被主流程直接join使用：</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code> {id:1,userid:2,service:3,a:1,b:2}
 {id:1,userid:2,service:2,a:3,b:2}</code></pre>
      </div>
<p>所以为了实现同事的需求，我需要第一将Rest接口的获取方式用标准的DataSource API 来实现，其次提供一个能够做如上合并规则的模块，并且允许配置。</p>
<p>最后实现的效果参看： <a href="https://gist.github.com/allwefantasy/42fd5afa2dc76f7bcc56e9e72977eaa3">Rest DataSource</a></p>
<p>实现代码可以参看：<a href="https://github.com/allwefantasy/streamingpro/tree/master/src/main/java/org/apache/spark/sql/execution/datasources/rest/json">RestJSONDataSource</a></p>
<h2>实现目标</h2>
<p>先看看DataSource API 的样子：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code>val df <span class="token operator">=</span> SQLContext<span class="token punctuation">.</span><span class="token function">getOrCreate</span><span class="token punctuation">(</span>sc<span class="token punctuation">)</span><span class="token punctuation">.</span>
read<span class="token punctuation">.</span>
<span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"driver class"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token comment">//驱动程序，类似JDBC的 driver class </span>
<span class="token function">options</span><span class="token punctuation">(</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token comment">//你需要额外传递给驱动的参数</span>
<span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token comment">//资源路径</span>
</code></pre>
      </div>
<p>如果做成配置化则是：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code><span class="token punctuation">{</span>
        <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"streaming.core.compositor.spark.source.SQLSourceCompositor"</span><span class="token punctuation">,</span>
        <span class="token string">"params"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">{</span>
            <span class="token string">"format"</span><span class="token punctuation">:</span> <span class="token string">"org.apache.spark.sql.execution.datasources.rest.json"</span><span class="token punctuation">,</span>
            <span class="token string">"url"</span><span class="token punctuation">:</span> <span class="token string">"http://[your dns]/path"</span><span class="token punctuation">,</span>
            <span class="token string">"xPath"</span><span class="token punctuation">:</span> <span class="token string">"$.data"</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
</code></pre>
      </div>
<h2>DefaultSource的实现</h2>
<p>定义</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>org.apache.spark.sql.execution.datasources.rest.json.DefaultSource
extends RelationProvider 
with DataSourceRegister</code></pre>
      </div>
<p>这是比较典型的命名规范。rest 代表支持的是rest作为接口，json则代表rest接口的数据是json格式的，包的命名让人一目了然。</p>
<p>先看看DefaultSource继承的两个接口</p>
<ul>
<li>DataSourceRegister</li>
</ul>
<p>该接口只有一个<code>shortName</code> 方法。我们看到上面的包名是很长的，你可以给一个更简短的名字：</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>org.apache.spark.sql.execution.datasources.rest.json 
==>
restJSON</code></pre>
      </div>
<p>所以具体实现就变成了：</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>override def shortName(): String = "restJSON"</code></pre>
      </div>
<ul>
<li>RelationProvider</li>
</ul>
<p>这个接口也只有一个方法：</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>def createRelation(sqlContext: SQLContext, parameters: Map[String, String]): BaseRelation</code></pre>
      </div>
<p>其返回值BaseRelation对象描述了数据源和Spark SQL交互。createRelation方法允许你根据用户定义的参数<code>parameters</code> 创建一个合适的BaseRelation的实现类。</p>
<p>其实除了这个，还有一些携带更多信息的继承自RelationProvider的类，譬如：</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>SchemaRelationProvider 允许你直接传递Schema信息给BaseRelation实现。
HadoopFsRelationProvider  除了参数帮你加了path等，返回值也帮你约定成HadoopFsRelation. HadoopFsRelation 提供了和HDFS交互的大部分实现</code></pre>
      </div>
<p>在我们的实现里，只要实现基础的RelationProvider就好。</p>
<p>我们来看下DefaultSource.createRelation的具体代码：</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>override def createRelation(
                               sqlContext: SQLContext,
                               //还记的DataSource的options方法么，parameters就是
                               //用户通过options传递过来的
                               parameters: Map[String, String]
                               ): BaseRelation = {
//因为我们并需要用户提供schema
//而是从JSON格式数据自己自己推导出来的
// 所以这里有个采样率的概念
    val samplingRatio = parameters.get("samplingRatio").map(_.toDouble).getOrElse(1.0)
// 还记得DataSource的 path么？ 理论上是应该通过那个传递过来的，然而
//这里是直接通过potions传递过来的。
    val url = parameters.getOrElse("url", "")
// 我们需要能够对通过XPATH语法抽取我们要的数据，比如
//前面的例子，我们需要能够抽取出data那个数组
    val xPath = parameters.getOrElse("xPath", "$")
   //这里是核心
    new RestJSONRelation(None, url, xPath, samplingRatio, None)(sqlContext)
  }</code></pre>
      </div>
<p>源码中已经做了说明。这里RestJSONRelation是整个核心，它实现了Spark SQL 和数据源的交互。RestJSONRelation继承自BaseRelation，TableScan等基类</p>
<h2>RestJSONRelation</h2>
<p>先看看RestJSONRelation 的签名：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code><span class="token keyword">private</span><span class="token punctuation">[</span>sql<span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">RestJSONRelation</span><span class="token punctuation">(</span>
                           val inputRDD<span class="token punctuation">:</span> Option<span class="token punctuation">[</span>RDD<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                           val url<span class="token punctuation">:</span> String<span class="token punctuation">,</span>
                           val xPath<span class="token punctuation">:</span> String<span class="token punctuation">,</span>
                           val samplingRatio<span class="token punctuation">:</span> Double<span class="token punctuation">,</span>
                           val maybeDataSchema<span class="token punctuation">:</span> Option<span class="token punctuation">[</span>StructType<span class="token punctuation">]</span>
                           <span class="token punctuation">)</span><span class="token punctuation">(</span>@transient val sqlContext<span class="token punctuation">:</span> SQLContext<span class="token punctuation">)</span>
  <span class="token keyword">extends</span> <span class="token class-name">BaseRelation</span> <span class="token keyword">with</span> TableScan <span class="token punctuation">{</span>
</code></pre>
      </div>
<p>这些参数是你随便定义的。当然，url,xPath,smaplingRatio具体的含义在上一章节都提到了。</p>
<p>和数据源进行交互有两个必要的信息需要获取：</p>
<ul>
<li>
<p>Schema 信息。只有两种方法：用户告知你，或者程序自己根据数据推导。关于schema信息这块，BaseRelation还提供了几个基础的约定：</p>
<ul>
<li>needConversion，是否需类型转换，因为Spark SQL内部的表示是Row,里面的数据需要特定的类型，比如String会被转化成UTF8String。默认为true,官方也是说不要管他就好。</li>
<li>unhandledFilters, 返回一些数据源没有办法pushdown的filter。这样解析器就知道可以在Spark内部做filter了。否则Spark 会傻傻的以为你做了过滤，然后数据计算结果就错了。</li>
</ul>
</li>
<li>
<p>数据扫描的方法。 目前Spark SQL 提供了四种</p>
<ul>
<li>TableScan 全表扫描</li>
<li>PrunedScan  可以指定列，其他的列数据源可以不用返回</li>
<li>PrunedFilteredScan 指定列，并且还可以加一些过滤条件，只返回满足条件的数据。这个也就是我们常说的数据源<code>下沉(pushdown)</code>操作。</li>
<li>CatalystScan 和PrunedFilteredScan类似，支持列过滤，数据过滤，但是接受的过滤条件是Spark 里的Expression。 理论上会更灵活些。话说在Spark源码)里(1.6.1版本)，我没有看到这个类的具体实现案例。
这里我们只要实现一个简单的TableScan就可以了，因为拿的是字典数据，并不需要做过滤。</li>
</ul>
</li>
</ul>
<h2>Schema推导</h2>
<p>BaseRelation是需要你给出Schema的。这里我们会先定义一个dataSchema的lazy属性，这样防止schema方法被反复调用而反复推导。</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>override def schema: StructType = dataSchema
lazy val dataSchema = .....</code></pre>
      </div>
<p>因为我们是根据数据推导Schema,所以首先要获取数据。我们定义一个方法：</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>private def createBaseRdd(inputPaths: Array[String]): RDD[String]</code></pre>
      </div>
<p>inputPaths 我沿用了文件系统的概念，其实在我们这里就是一个URL。我们知道，最终Spark SQL 的直接数据源都是RDD的。所以这里我们返回的也是RDD[String]类型。具体实现很简单，就是通过HttpClient根据inputPaths拿到数据之后makeRDD一下就可以了。</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code><span class="token comment">//应该要再加个重试机制就更好了</span>
<span class="token keyword">private</span> def <span class="token function">createBaseRdd</span><span class="token punctuation">(</span>inputPaths<span class="token punctuation">:</span> Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> RDD<span class="token punctuation">[</span>String<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val url <span class="token operator">=</span> inputPaths<span class="token punctuation">.</span>head
    val res <span class="token operator">=</span> Request<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>toURI<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    val response <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">returnResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    val content <span class="token operator">=</span> EntityUtils<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>getEntity<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>response <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> response<span class="token punctuation">.</span>getStatusLine<span class="token punctuation">.</span>getStatusCode <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//这里是做数据抽取的，把data的数组给抽取出来</span>
      <span class="token keyword">import</span> scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>JavaConversions<span class="token punctuation">.</span>_
      val extractContent <span class="token operator">=</span> JSONArray<span class="token punctuation">.</span><span class="token function">fromObject</span><span class="token punctuation">(</span>JSONPath<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> xPath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
        <span class="token function">map</span><span class="token punctuation">(</span>f <span class="token operator">=></span> JSONObject<span class="token punctuation">.</span><span class="token function">fromObject</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">.</span>toSeq
      sqlContext<span class="token punctuation">.</span>sparkContext<span class="token punctuation">.</span><span class="token function">makeRDD</span><span class="token punctuation">(</span>extractContent<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      sqlContext<span class="token punctuation">.</span>sparkContext<span class="token punctuation">.</span><span class="token function">makeRDD</span><span class="token punctuation">(</span><span class="token function">Seq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
      </div>
<p>有了这个类就能获取到数据，就可以做Schema推导了：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code> lazy val dataSchema <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token comment">//我们也允许用户传递给我们Schema,如果没有就自己推导</span>
    val jsonSchema <span class="token operator">=</span> maybeDataSchema<span class="token punctuation">.</span>getOrElse <span class="token punctuation">{</span>      
      <span class="token function">InferSchema</span><span class="token punctuation">(</span>
        <span class="token comment">//拿到数据</span>
        inputRDD<span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token function">createBaseRdd</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token comment">//采样率，其实就是拿sc.sample方法</span>
        samplingRatio<span class="token punctuation">,</span>
        sqlContext<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>columnNameOfCorruptRecord<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">checkConstraints</span><span class="token punctuation">(</span>jsonSchema<span class="token punctuation">)</span>

    jsonSchema
  <span class="token punctuation">}</span>
</code></pre>
      </div>
<p>InferSchema的实现逻辑比较复杂，但最终就是为了返回StructType(fields: Array[StructField]) 这么个东西。我是直接拷贝的spark JSON DataSource的实现。有兴趣的可以自己参看。StructType其实也很简单了，无非就是一个描述Schema的结构，类似你定义一张表，你需要告诉系统字段名称，类型，是否为Null等一些列信息。</p>
<p>现在我们终于搞定了数据表结构了。</p>
<h2>数据获取</h2>
<p>刚才我们说了数据获取的四种类型，我们这里使用的是TableScan,继承自该接口只要实现一个buildScan方法就好：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code>def <span class="token function">buildScan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> RDD<span class="token punctuation">[</span>Row<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">JacksonParser</span><span class="token punctuation">(</span>
      inputRDD<span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token function">createBaseRdd</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      dataSchema<span class="token punctuation">,</span>      sqlContext<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>columnNameOfCorruptRecord<span class="token punctuation">)</span><span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span>RDD<span class="token punctuation">[</span>Row<span class="token punctuation">]</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
</code></pre>
      </div>
<p>其本质工作就是把JSON格式的String根据我们前面已经拿到的Schema转化为Row格式。</p>
<p>具体做法如下：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code><span class="token comment">//这个是createBaseRDD返回的RDD[String]</span>
<span class="token comment">//对应的String 其实是JSON格式</span>
<span class="token comment">//针对每个分区做处理</span>
json<span class="token punctuation">.</span>mapPartitions <span class="token punctuation">{</span> iter <span class="token operator">=></span>
      val factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      iter<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> record <span class="token operator">=></span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token comment">//JSON的解析器</span>
          val parser <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createParser</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span>
          parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token comment">//这里开始做类型转换了</span>
          <span class="token function">convertField</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> parser<span class="token punctuation">,</span> schema<span class="token punctuation">)</span> match <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token keyword">null</span> <span class="token operator">=></span> <span class="token function">failedRecord</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span>
            <span class="token keyword">case</span> row<span class="token punctuation">:</span> InternalRow <span class="token operator">=></span> row <span class="token punctuation">:</span><span class="token punctuation">:</span> Nil
            <span class="token keyword">case</span> array<span class="token punctuation">:</span> ArrayData <span class="token operator">=></span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">numElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Nil
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                array<span class="token punctuation">.</span>toArray<span class="token punctuation">[</span>InternalRow<span class="token punctuation">]</span><span class="token punctuation">(</span>schema<span class="token punctuation">)</span>
              <span class="token punctuation">}</span>
            <span class="token keyword">case</span> _ <span class="token operator">=></span>
              sys<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>
                s<span class="token string">"Failed to parse record $record. Please make sure that each line of the file "</span> <span class="token operator">+</span>
                  <span class="token string">"(or each string in the RDD) is a valid JSON object or an array of JSON objects."</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
          <span class="token keyword">case</span> _<span class="token punctuation">:</span> JsonProcessingException <span class="token operator">=></span>
            <span class="token function">failedRecord</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
      </div>
<p>这里的代码还是比较清晰易懂的。但是 convertField(factory, parser, schema) 直接match 到  InternalRow 还是比较让人困惑的，一个字段转换咋就变成了InternalRow了呢？这里确实也有乾坤的。我们进去看看convertField方法：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code> <span class="token keyword">private</span><span class="token punctuation">[</span>sql<span class="token punctuation">]</span> def <span class="token function">convertField</span><span class="token punctuation">(</span>
      factory<span class="token punctuation">:</span> JsonFactory<span class="token punctuation">,</span>
      parser<span class="token punctuation">:</span> JsonParser<span class="token punctuation">,</span>
      schema<span class="token punctuation">:</span> DataType<span class="token punctuation">)</span><span class="token punctuation">:</span> Any <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>core<span class="token punctuation">.</span>JsonToken<span class="token punctuation">.</span><span class="token function">_</span>
    <span class="token punctuation">(</span>parser<span class="token punctuation">.</span>getCurrentToken<span class="token punctuation">,</span> schema<span class="token punctuation">)</span> match <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">|</span> VALUE_NULL<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token keyword">null</span>

      <span class="token keyword">case</span> <span class="token punctuation">(</span>FIELD_NAME<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=></span>
        parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">convertField</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> parser<span class="token punctuation">,</span> schema<span class="token punctuation">)</span>

     <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
     <span class="token keyword">case</span> <span class="token punctuation">(</span>START_OBJECT<span class="token punctuation">,</span> st<span class="token punctuation">:</span> StructType<span class="token punctuation">)</span> <span class="token operator">=></span>  
       <span class="token function">convertObject</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> parser<span class="token punctuation">,</span> st<span class="token punctuation">)</span>
</code></pre>
      </div>
<p>如果你的JSON是个Map,经过N次匹配case后会进入最后一个case 情况。这里的st:StructType 就是我们之前自己推导出来的dataSchema. convertObject 方法如下：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">nextUntil</span><span class="token punctuation">(</span>parser<span class="token punctuation">,</span> JsonToken<span class="token punctuation">.</span>END_OBJECT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      schema<span class="token punctuation">.</span><span class="token function">getFieldIndex</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span>getCurrentName<span class="token punctuation">)</span> match <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token function">Some</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">=></span>
          row<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token function">convertField</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> parser<span class="token punctuation">,</span> <span class="token function">schema</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>dataType<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">case</span> None <span class="token operator">=></span>
          parser<span class="token punctuation">.</span><span class="token function">skipChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
      </div>
<p>到这里就真相大白了。为了能够拿到一条完整的数据，他会while循环直到遇到END<em>OBJECT 。所谓END</em>OBJECT 其实就是一个Map 结束了。 在每一次循环里，拿到一个字段，然后通过名字去schema里获取类型信息，然后再回调convertField方法将这个字段转化为row需要的类型，比如字符串类型的就通过UTF8String进行转换。</p>
<div class="gatsby-highlight">
      <pre class="language-none"><code>case (VALUE_STRING, StringType) =>  UTF8String.fromString(parser.getText)</code></pre>
      </div>
<p>得到的值通过Row的函数进行更新,这里是 row.update 方法。到END_OBJECT后，就完成了将一个JSON Map 转化为一条Row的功能了。</p>
<h2>收工</h2>
<p>到目前为止，我们已经完成了具体的工作了。现在你已经可以按如下的方式使用：</p>
<div class="gatsby-highlight">
      <pre class="language-js"><code>val df <span class="token operator">=</span> SQLContext<span class="token punctuation">.</span><span class="token function">getOrCreate</span><span class="token punctuation">(</span>sc<span class="token punctuation">)</span><span class="token punctuation">.</span>
read<span class="token punctuation">.</span>
<span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"org.apache.spark.sql.execution.datasources.rest.json"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token comment">//驱动程序，类似JDBC的 driver class </span>
<span class="token function">options</span><span class="token punctuation">(</span><span class="token function">Map</span><span class="token punctuation">(</span>
<span class="token string">"url"</span><span class="token operator">-</span><span class="token operator">></span><span class="token string">"http://[your dns]/path"</span>
<span class="token string">"xPath"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"$.data"</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token comment">//你需要额外传递给驱动的参数</span>
<span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token comment">//资源路径</span>
</code></pre>
      </div>
<p>获取到的Dataframe 你可以做任意的操作。</p>
<h2>总结</h2>
<p>Spark DataSource API的提出，给Spark 构建生态带来了巨大的好处。各个存储系统可以实现统一标准的接口去对接Spark。学会使用自己实现一个DataSoure是的你的存储可以更好的和生态结合，也能得到更好的性能优化。</p></div><div class="sc-ifAKCX jorVQO" data-reactid="10"><div data-reactid="11"><a href="/myblog/posts/2" data-reactid="12">Prev</a></div><div data-reactid="13"><a href="/myblog/posts/4" data-reactid="14">Next</a></div></div></div></div></div></div></div></body></html>